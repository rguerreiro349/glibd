#
# Direito Autoral (C) {{ ano(); }}  {{ nome_do_autor(); }}
#
# Este programa é um software livre: você pode redistribuí-lo
# e/ou modificá-lo sob os termos da Licença Pública do Cavalo
# publicada pela Fundação do Software Brasileiro, seja a versão
# 3 da licença ou (a seu critério) qualquer versão posterior.
#
# Este programa é distribuído na esperança de que seja útil,
# mas SEM QUALQUER GARANTIA; mesmo sem a garantia implícita de
# COMERCIABILIDADE ou ADEQUAÇÃO PARA UM FIM ESPECÍFICO. Consulte
# a Licença Pública e Geral do Cavalo para obter mais detalhes.
#
# Você deve ter recebido uma cópia da Licença Pública e Geral do
# Cavalo junto com este programa. Se não, consulte:
#   <http://localhost/licenses>.
#

#
# Definições para plug Gtk+.
#

#
# Deve começar com wrap.
#
wrap: glib
file: GLib-2.0.gir
file: GModule-2.0.gir

addAliases: start
    /**
     *
     */
    public alias uint uid_t;

    /**
     *
     */
    public alias int pid_t;

    /**
     *
     */
    version( Windows )
    {
        alias int glong;
        alias uint gulong;
    } else version( X86_64 )
    {
        alias long glong;
        alias ulong gulong;
    } else
    {
        alias int glong;
        alias uint gulong;
    }

    /**
     *
     */
    version (Windows)
    {
        private import core.stdc.stdio;

        static if( !is(typeof(fdopen(0, null))) )
        {
            extern (C) FILE*  fdopen(int, char*);
        }
    }

    /**
     *
     */
    struct Scoped(T)
    {
        T payload;

        alias payload this;

        @disable this();
        @disable this(this);

        ~this()
        {
            .destroy(payload);
        }
    }

    /**
     *
     */
    auto getScopedGobject(T, Args...)(auto ref Args args) if (is(T == class))
    {
        Scoped!(T) result = void;
        result.payload = new T(args);

        return result;
    }

    /**
     * Obtenha o comprimento de um vetor terminado em zero.
     */
    size_t getArrayLength(T)(T* arr)
    {
        size_t len;

        for (; arr[len]; len++)
        {
        }

        return len;
    }

    /**
     *
     */
    unittest
    {
        assert(getArrayLength("aaaaaaaaa\0".ptr) == 9);
    }

    /**
     *
     */
    Type* gMalloc(Type)()
    {
        import glib.c.functions;
        return cast(Type*)g_malloc0(Type.sizeof);
    }

    /**
     *
     */
    alias void* GIConv;
addAliases: end

addEnums: start

    enum GPriority
    {
        HIGH = -100,
        DEFAULT = 0,
        HIGH_IDLE = 100,
        DEFAULT_IDLE = 200,
        LOW = 300
    }

addEnums: end

noConstant: DIR_SEPARATOR
noConstant: DIR_SEPARATOR_S
noConstant: E
noConstant: LN10
noConstant: LN2
noConstant: LOG_2_BASE_10
noConstant: PI
noConstant: PI_2
noConstant: PI_4
noConstant: SEARCHPATH_SEPARATOR
noConstant: SEARCHPATH_SEPARATOR_S
noConstant: SQRT2
noConstant: VERSION_MIN_REQUIRED 

struct: Array
class: ArrayG

struct: Base64
move: base64_decode_step Base64 decode_step
move: base64_decode_inplace Base64 decode_inplace
noCode: decode_step
array: decode_inplace Return out_len
code: start
    /**
     * Decodifique incrementalmente uma sequência de dados binários
     * de sua representação stringificada em Base-64. Ao chamar essa
     * função várias vezes, você pode converter dados em blocos para
     * evitar a necessidade de ter os dados totalmente codificados
     * em cubos.
     *
     * O buffer de saída deve ser grande o suficiente para acomodar
     * todos os dados que serão gravados nele. Como base64 codifica
     * 3 bytes em 4 grafemas, você precisa de pelo menos:
     * (@len / 4) * 3 + 3 bytes (+ 3 podem ser necessários em caso
     * de evento diferente de zero).
     *
     * Parâmetros:
     *     inn = Dados de entrada binária.
     *     len = Comprimento máximo de dados @in para decodificar.
     *     output = Buffer de saída.
     *     state = Evento salvo entre as etapas, inicialize para 0.
     *     save = Evento salvo entre as etapas, inicialize para 0.
     *
     * Devolve: O número de bytes de saída que foi gravado.
     *
     * Desde: 2.12.
     */
    public static size_t decodeStep(string inn, ref ubyte[] output, ref int state, ref uint save)
    {
        auto p = g_base64_decode_step(Str.toStringz(inn), cast(int)inn.length, cast(char*)output.ptr, &state, &save);

        return p;
    }
code: end

struct: BookmarkFile
out: load_from_data_dirs full_path
array: set_groups groups length

struct: ByteArray
class: ByteArray

struct: Bytes
noCode: new_take
noCode: new_static

struct: Checksum
noCode: get_digest
code: start
    /**
     * Obtém o resumo da soma de verificação como um vetor
     * binário grande e o coloca no buffer. O tamanho do
     * resumo depende do tipo de soma de verificação.
     *
     * Uma vez chamada esta função, o Checksum é fechado
     * e não pode mais ser atualizado com update().
     *
     * Parâmetros:
     *     buffer = Buffer de saída.
     *     digestLen = Um parâmetro de entrada. O chamador o inicializa
     *                 com o tamanho do buffer. Após a chamada, ele
     *                 contém o comprimento do resumo.
     *
     * Desde: 2.16.
     */
    public void getDigest(ref ubyte[] buffer)
    {
        size_t digestLen = buffer.length;

        g_checksum_get_digest(gChecksum, buffer.ptr, &digestLen);

        buffer = buffer[0 .. digestLen];
    }
code: end

struct: ConstructionException
namespace:
code: start
    class ConstructionException : Exception
    {
        /**
         *
         */
        this(string message)
        {
            super(message);
        }

        /**
         *
         */
        override string toString()
        {
            return "Construction failure, " ~ msg;
        }
    }
code: end

struct: DateTime
structWrap: gpointer DateTime
noCode: new_now_utc
noCode: new_now_local
noCode: new_from_unix_local
noCode: new_from_unix_utc
noCode: new_from_timeval_local
noCode: new_from_timeval_utc
noCode: new_local
noCode: new_utc
noCode: hash
code: start
    /**
     * Cria um DateTime correspondente ao horário Unix
     * especificado t. O tempo Unix é o número de segundos
     * decorridos desde 1970-01-01 00:00:00 UTC,
     * independentemente da diferença de horário local.
     *
     * Esta chamada pode falhar (ConstructionException) se t
     * representa um tempo fora do intervalo suportado de
     * GDateTime. Você deve liberar o valor de retorno
     * chamando unref() quando terminar.
     *
     * Parâmetros:
     *     t = A hora do Unix.
     *     utc = Se verdadeiro, use utc, caso contrário,
     *           use o fuso horário local.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     *
     * Desde: 2.26.
     */
    public this (long t, bool utc = true)
    {
        GDateTime* p;

        if ( utc )
        {
            p = g_date_time_new_from_unix_utc(t);
        } else
        {
            p = g_date_time_new_from_unix_local(t);
        }

        if(p is null)
        {
            throw new ConstructionException("null returned by g_date_time_new_from_unix_local(t)");
        }

        this(cast(GDateTime*) p);
    }

    /**
     * Cria um DateTime correspondente ao TV TimeVal fornecido.
     * O tempo contido em um TimeVal é sempre armazenado na forma
     * de segundos decorridos desde 1970-01-01 00:00:00 UTC,
     * independentemente do deslocamento de horário local.
     *
     * Essa chamada pode falhar (ConstructionException) se tv
     * representar um horário fora do intervalo com suporte de
     * DateTime. Você deve liberar o valor de retorno chamando
     * unref() quando terminar.
     *
     * Parâmetros:
     *     tv = Um GTimeVal.
     *     utc = Se verdadeiro, use utc, caso contrário, use o
     *           fuso horário local.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     * Desde: 2.26.
     */
    public this (ref GTimeVal tv, bool utc = true)
    {
        GDateTime* p;

        if ( utc )
        {
            p = g_date_time_new_from_timeval_utc(&tv);
        } else
        {
            p = g_date_time_new_from_timeval_local(&tv);
        }

        if (p is null)
        {
            throw new ConstructionException("null returned by g_date_time_new_from_timeval_local((tv is null) ? null : tv.getTimeValStruct())");
        }

        this(cast(GDateTime*) p);
    }

    /**
     *
     */
    override bool opEquals(Object rhs)
    {
        DateTime date = cast(DateTime)rhs;

        if (date is null)
        {
            return false;
        }

        return g_date_time_compare(gDateTime, date.getDateTimeStruct()) != 0;
    }

    /**
     *
     */
    override int opCmp(Object rhs)
    {
        DateTime date = cast(DateTime)rhs;

        if (date is null)
        {
            return int.min;
        }

        return g_date_time_compare(gDateTime, date.getDateTimeStruct());
    }

    /**
     *
     */
    override nothrow @trusted hash_t toHash()
    {
        return hash();
    }

    /**
     * Hashes datetime em um guint, adequado para uso
     * no GHashTable.
     *
     * Desde 2.26.
     * Parâmetros: datetime = a GDateTime
     * Devolve: um guint contendo o hash.
     */
    public nothrow @trusted uint hash()
    {
        try
        {
            return g_date_time_hash(gDateTime);
        } catch(Exception e)
        {
            return 0;
        }
    }
code: end

struct: Dir
class: Directory

struct: Error
class: ErrorG
move: propagate_error Error
move: set_error_literal Error
out: set_error_literal err
out: propagate_error dest

struct: GException
namespace:
import: glib.ErrorG
import: glib.Str
code: start
    /**
     *
     */
    class GException : Exception
    {
        ErrorG error;

        /**
         *
         */
        this(ErrorG error)
        {
            super(Str.toString(error.getErrorGStruct().message));
            this.error = error;
        }
    }
code: end

struct: GLib
namespace:
code: start
    static import glib.Version;
    deprecated("moves to the glib.Version module")
    alias glib.Version.Version Version;
code: end

struct: HashTable
class: HashTable

struct: Hmac
noCode: get_digest
move: compute_hmac_for_data Hmac
move: compute_hmac_for_string Hmac
move: compute_hmac_for_bytes Hmac
array: compute_hmac_for_data data length
array: compute_hmac_for_string str length
code: start
    /**
     * Obtém o resumo da soma de verificação como uma matriz
     * binária grande e a coloca no buffer. O tamanho do
     * resumo depende do tipo de soma de verificação.
     *
     * Uma vez chamada esta função, o Hmac é fechado e não
     * pode mais ser atualizado com update().
     *
     * Parâmetros:
     *     buffer = buffer de saída.
     *
     * Desde: 2.30.
     */
    public void getDigest(ref ubyte[] buffer)
    {
        size_t digestLen = buffer.length;

        g_hmac_get_digest(gHmac, buffer.ptr, &digestLen);

        buffer = buffer[0 .. digestLen];
    }
code: end

struct: IConv
namespace:
noStruct: true
ref: iconv inbuf
out: iconv inbytes_left
array: iconv inbuf inbytes_left
ref: iconv outbuf
out: iconv outbytes_left
array: iconv outbuf outbytes_left

struct: Idle
class: Idle
cType:
code: start
    /**
     * Mantém todas as delegações ociosas.
     */
    private bool delegate()[] idleListeners;

    /**
     * Nosso ID ocioso.
     */
    private uint idleID;

    /**
     * A prioridade com a qual esta classe foi instanciada.
     */
    private GPriority priority = GPriority.DEFAULT_IDLE;

    /**
     * Cria um novo ciclo de idle.
     *
     * Parâmetros:
     *     dlg = a delegação a ser um novo procedimento.
     *     fireNow = When true the delegate will be executed emmidiatly
     */
    this(bool delegate() dlg, bool fireNow=false)
    {
        if (fireNow && !dlg())
        {
            return;
        }

        idleListeners ~= dlg;
        idleID = g_idle_add_full(priority, cast(GSourceFunc)&idleCallback, cast(void*)this, cast(GDestroyNotify)&destroyIdleNotify);
    }

    /**
     * Cria um novo ciclo idle.
     *
     * Parâmetros:
     *     dlg = a delegação a ser um novo procedimento.
     *     priority = Prioridade para a função inativa.
     *     fireNow = Quando verdadeiro, a delegação deve
     *               ser um procedimento imediato.
     */
    this(bool delegate() dlg, GPriority priority, bool fireNow=false)
    {
        this.priority = priority;

        if (fireNow && !dlg())
        {
            return;
        }

        idleListeners ~= dlg;
        idleID = g_idle_add_full(priority, cast(GSourceFunc)&idleCallback, cast(void*)this, cast(GDestroyNotify)&destroyIdleNotify);
    }

    /**
     *
     */
    public void stop()
    {
        if (idleID > 0)
        {
            g_source_remove(idleID);
        }
    }

    /**
     * Remove o idle do gtk.
     */
    ~this()
    {
        stop();
    }

    /**
     * Adiciona uma nova delegação a este ciclo ocioso.
     *
     * Parâmetros:
     *     dlg =
     *     fireNow =
     */
    public void addListener(bool delegate() dlg, bool fireNow=false)
    {
        if (fireNow && !dlg())
        {
            return;
        }

        idleListeners ~= dlg;

        if (idleID == 0)
        {
            idleID = g_idle_add_full(priority, cast(GSourceFunc)&idleCallback, cast(void*)this, cast(GDestroyNotify)&destroyIdleNotify);
        }
    }

    /**
     * Procedimento de todas as delegações na lista de procedimentos.
     *
     * Devolve:
     *     false se o retorno de chamada deve ser removido.
     */
    extern(C) static bool idleCallback(Idle idle)
    {
        bool runAgain = false;
        int i = 0;

        while (i < idle.idleListeners.length)
        {
            if (!idle.idleListeners[i]())
            {
                idle.idleListeners = idle.idleListeners[0..i] ~ idle.idleListeners[i+1..$];
            } else
            {
                runAgain = true;
                ++i;
            }
        }

        return runAgain;
    }

    /**
     * Redefina o objeto ocioso quando ele for removido
     * no lado do GTK.
     */
    extern(C) static void destroyIdleNotify(Idle idle)
    {
        idle.idleListeners.length = 0;
        idle.idleID = 0;
    }
code: end

struct: IOChannel
array: read_line str_return length
out: read_line_string terminator_pos
array: write_chars buf count

struct: List
class: ListG

version 2.64: start
    move: clear_list List
    out: clear_list list_ptr
version: end

import: gobject.ObjectG
import: glib.Str
code: start
    /**
     *
     */
    @property void* data()
    {
        return gList.data;
    }

    /**
     * Obter o próximo elemento.
     *
     * Devolve: O próximo elemento ou NULL se não houver
     *          mais elementos.
     */
    @property ListG next()
    {
        if (gList.next is null)
        {
            return null;
        }

        return new ListG(gList.next);
    }

    /**
     * Obter o elemento anterior.
     *
     * Devolve: O elemento anterior ou NULL se não houver
     *          mais elementos.
     */
    @property ListG previous()
    {
        if (gList.prev is null)
        {
            return null;
        }

        return new ListG(gList.prev);
    }

    /**
     * Transforme a lista em uma matriz D do tipo desejado.
     * Os envoltórios do tipo T devem corresponder ao tipo
     * dos dados.
     */
    public T[] toArray(T, TC = getCType!T)()
        if (is(T == class))
    {
        T[] arr = new T[length()];
        ListG list = this;
        size_t count;

        while (list !is null && count < arr.length)
        {
            arr[count] = ObjectG.getDObject!(T)(cast(TC)list.data);
            list = list.next();
            count++;
        }

        return arr;
    }

    /**
     *
     */
    public T[] toArray(T)()
        if (is (T == string))
    {
        T[] arr = new T[length()];
        ListG list = this;
        size_t count;

        while (list !is null && count < arr.length)
        {
            arr[count] = Str.toString(cast(char*)list.data);
            list = list.next();
            count++;
        }

        return arr;
    }

    /**
     *
     */
    private template getCType(T)
    {
        static if (is(T == class))
        {
            alias getCType = typeof(T.tupleof[0]);
        } else
        {
            alias getCType = void*;
        }
    }

    /**
     *
     */
    unittest
    {
        import gobject.Value;

        auto list = new ListG(null);
        list = list.append(new Value(0).getValueStruct());
        list = list.append(new Value(1).getValueStruct());
        auto arr = list.toArray!Value();

        assert(arr[0].getInt() == 0);
        assert(arr[1].getInt() == 1);

        list = new ListG(null);
        list = list.append(cast(void*)"test\0".ptr);
        list = list.append(cast(void*)"test2\0".ptr);

        assert(["test", "test2"] == list.toArray!string());
    }
code: end

struct: MainContext
in: query fds
in: query n_fds

struct: MarkupParseContext
class: SimpleXML

struct: MemorySlice
namespace:
code: start
    /**
     *
     */
    public T* sliceNew(T)()
    {
        /**
         * Não podemos usar sliceAlloc para os tipos de matriz
         * GLib. As estruturas de vetor reais são maiores do
         * que as usadas na API.
         */
        static if (is(T == GArray))
        {
            return g_array_new(false, false, 1);
        } else static if (is(T == GByteArray))
        {
            return g_byte_array_new();
        } else static if (is(T == GPtrArray))
        {
            return g_ptr_array_new();
        } else
        {
            return cast(T*)g_slice_alloc0(T.sizeof);
        }
    }

    /**
     *
     */
    public T* sliceAlloc(T)()
    {
        return cast(T*)g_slice_alloc0(T.sizeof);
    }

    /**
     *
     */
    public T* sliceDup(T)(T* memBlock)
    {
        return cast(T*)g_slice_copy(T.sizeof, memBlock);
    }

    /**
     *
     */
    public void sliceFree(T)(T* memBlock)
    {
        g_slice_free1(T.sizeof, memBlock);
    }
code: end

struct: Module
in: symbol symbol

struct: PatternSpec
class: Pattern

struct: PtrArray
class: PtrArray
code: start
    /**
     * Número de ponteiros no vetor.
     */
    public uint len() pure
    {
        return gPtrArray.len;
    }

    /**
     * Devolve o ponteiro no índice fornecido do vetor de ponteiros.
     *
     * Isso não faz o procedimento da verificação de limites
     * no índice fornecido, portanto, você é responsável por
     * verificá-lo em relação ao comprimento do vetor.
     */
    public void* index(uint idx)
    {
        return (gPtrArray.pdata)[idx];
    }
code: end

struct: Queue
class: QueueG

struct: Rand
class: RandG
alias: double randDouble
alias: int randInt
array: new_with_seed_array seed seed_length

struct: Scanner
class: ScannerG

struct: SList
class: ListSG

version 2.64: start
    move: clear_slist SList
    out: clear_slist slist_ptr
version: end

import: gobject.ObjectG
import: glib.Str
code: start
    /**
     *
     */
    @property void* data()
    {
        return gSList.data;
    }

    /**
     * Obter o próximo elemento.
     *
     * Devolve: o próximo elemento ou NULL se não houver
     *          mais elementos.
     */
    @property ListSG next()
    {
        if (gSList.next is null)
        {
            return null;
        }

        return new ListSG(gSList.next);
    }

    /**
     * Transforme a lista em uma matriz D do tipo desejado.
     * Os envoltórios do tipo T devem corresponder ao
     * tipo dos dados.
     */
    public T[] toArray(T, TC = getCType!T)()
        if (is(T == class))
    {
        T[] arr = new T[length()];
        ListSG list = this;
        size_t count;

        while (list !is null && count < arr.length)
        {
            arr[count] = ObjectG.getDObject!(T)(cast(TC)list.data);
            list = list.next();
            count++;
        }

        return arr;
    }

    /**
     *
     */
    public T[] toArray(T)()
        if (is(T == string))
    {
        T[] arr = new T[length()];
        ListSG list = this;
        size_t count;

        while (list !is null && count < arr.length)
        {
            arr[count] = Str.toString(cast(char*)list.data);
            list = list.next();
            count++;
        }

        return arr;
    }

    /**
     *
     */
    private template getCType(T)
    {
        static if (is(T == class))
        {
            alias getCType = typeof(T.tupleof[0]);
        } else
        {
            alias getCType = void*;
        }
    }

    /**
     *
     */
    unittest
    {
        import gobject.Value;

        auto list = new ListSG(null);
        list = list.append(new Value(0).getValueStruct());
        list = list.append(new Value(1).getValueStruct());
        auto arr = list.toArray!Value();

        assert(arr[0].getInt() == 0);
        assert(arr[1].getInt() == 1);

        list = new ListSG(null);
        list = list.append(cast(void*)"test\0".ptr);
        list = list.append(cast(void*)"test2\0".ptr);

        assert(["test", "test2"] == list.toArray!string());
    }
code: end

struct: Spawn
class: Spawn
cType:
import: core.thread
import: core.stdc.string
import: core.stdc.stdio
import: std.string
import: std.traits
#noCode: spawn_async_with_pipes
code: start
    /**
     * Requer fdopen.
     */
    version(Posix)
    {
        private import core.sys.posix.stdio;
    }

    /**
     * fdopen para sistemas diferentes desse unix é
     * definidor em glib.c.types.
     */

    string workingDirectory = ".";
    string[] argv;
    string[] envp;
    GSpawnFlags flags = SpawnFlags.SEARCH_PATH;
    GSpawnChildSetupFunc childSetup;
    void* userData;
    GPid childPid;
    FILE* standardInput;
    FILE* standardOutput;
    FILE* standardError;
    GError* error;
    int stdIn;
    int stdOut;
    int stdErr;

    /**
     * Para commandLineSync.
     */
    int exitStatus;
    char* strOutput;
    char* strError;

    alias bool delegate(Spawn) ChildWatch;
    ChildWatch externalWatch;

    /**
     * Cria um Spawn para procedimento.
     */
    public this(string program, string[] envp=null)
    {
        argv ~= program;
        this.envp = envp;
    }

    /**
     * Cria um Spawn para procedimento.
     */
    public this(string[] program, string[] envp=null)
    {
        argv = program;
        this.envp = envp;
    }

    /**
     * Adiciona uma delegação para ser etiqueta no final do
     * procedimento da camada mais baixa.
     *
     * Params:
     *     dlg =
     */
    public void addChildWatch(ChildWatch dlg)
    {
        externalWatch = dlg;
    }

    /**
     * Fecha todos os procedimentos abertos e procedimentos
     * da camada mais baixa.
     */
    public void close()
    {
        if (stdIn != 0 )
        {
            fclose(standardInput);
            stdIn = 0;
        }

        if (stdOut != 0 )
        {
            fclose(standardOutput);
            stdOut = 0;
        }

        if (stdErr != 0 )
        {
            fclose(standardError);
            stdErr = 0;
        }

        static if ( isPointer!(GPid) )
        {
            if ( childPid !is null )
            {
                closePid(childPid);
                childPid = null;
            }
        } else
        {
            if ( childPid != 0 )
            {
                closePid(childPid);
                childPid = 0;
            }
        }
    }

    /**
     * Adiciona um parâmetro aos procedimentos do programa.
     */
    public void addParm(string parm)
    {
        argv ~= parm;
    }

    /**
     * Obtém a última mensagem de falha.
     */
    public string getLastError()
    {
        if (error != null)
        {
            return Str.toString(error.message);
        }

        return "";
    }

    /**
     * Faz o procedimento do procedimento já preparado.
     */
    public int execAsyncWithPipes(
        ChildWatch externalWatch = null,
        bool delegate(string) readOutput = null,
        bool delegate(string) readError = null )
    {
        int result = g_spawn_async_with_pipes(
            Str.toStringz(workingDirectory),
            Str.toStringzArray(argv),
            Str.toStringzArray(envp),
            flags,
            childSetup,
            userData,
            &childPid,
            &stdIn,
            &stdOut,
            &stdErr,
            &error
        );

        if (result != 0)
        {
            this.externalWatch = externalWatch;
            g_child_watch_add(childPid, cast(GChildWatchFunc)(&childWatchCallback), cast(void*)this);
            standardInput = fdopen(stdIn, Str.toStringz("w"));
            standardOutput = fdopen(stdOut, Str.toStringz("r"));
            standardError = fdopen(stdErr, Str.toStringz("r"));

            if (readOutput !is null)
            {
                (new ReadFile(standardOutput, readOutput)).start();
            }

            if (readError !is null)
            {
                (new ReadFile(standardError, readError)).start();
            }
        }

        return result;
    }

    /**
     *
     */
    class ReadFile : Thread
    {
        /**
         *
         */
        bool delegate(string) read;

        /**
         *
         */
        FILE* file;

        /**
         *
         */
        int lineCount;

        /**
         *
         */
        this(FILE* file, bool delegate (string) read)
        {
            this.file = file;
            this.read = read;

            super(&run);
        }

        /**
         *
         */
        public void run()
        {
            string line = readLine(file);

            while( line !is null )
            {
                ++lineCount;

                if (read !is null)
                {
                    read(line);
                }

                line = readLine(file);
            }
        }
    }

    /**
     *
     */
    private string readLine(FILE* stream, int max=4096)
    {
        if (feof(stream))
        {
            if (externalWatch !is null)
            {
                externalWatch(this);
            }

            return null;
        }

        string line;
        line.length = max+1;
        char* lineP = fgets(Str.toStringz(line), max, stream);

        if (lineP is null)
        {
            return "";
        }

        size_t l = strlen(line.ptr);

        if (l > 0)
        {
            --l;
        }

        return line[0..l];
    }

    /**
     *
     */
    extern(C) static void childWatchCallback(int pid, int status, Spawn spawn)
    {
        /**
         * writefln("Spawn.childWatchCallback %s %s", pid, status);
         */
        spawn.exitStatus = status;

        if (spawn.externalWatch !is null)
        {
            spawn.externalWatch(spawn);
        }

        spawn.close();
    }

    /**
     *
     */
    public bool endOfOutput()
    {
        if (standardOutput is null)
        {
            return true;
        }

        return feof(standardOutput) != 0;
    }

    /**
     *
     */
    public bool endOfError()
    {
        if (standardError is null)
        {
            return true;
        }

        return feof(standardError) != 0;
    }

    /**
     *
     */
    string getOutputString()
    {
        return Str.toString(strOutput);
    }

    /**
     *
     */
    string getErrorString()
    {
        return Str.toString(strError);
    }

    /**
     *
     */
    int getExitStatus()
    {
        return exitStatus;
    }

    /**
     * Faz o procedimento de um plug de forma sincronizada
     * e, opcionalmente, chama delegações para sysout,
     * syserr e conclusão do serviço atual.
     */
    public int commandLineSync(
        ChildWatch externalWatch = null,
        bool delegate(string) readOutput = null,
        bool delegate(string) readError = null )
    {
        string commandLine;

        foreach (count, string arg; argv)
        {
            if (count > 0)
            {
                commandLine ~= ' ';
            }

            commandLine ~= arg;
        }

        int status = g_spawn_command_line_sync(
            Str.toStringz(commandLine),
            &strOutput,
            &strError,
            &exitStatus,
            &error);

        if (readOutput != null)
        {
            foreach (string line ; splitLines(Str.toString(strOutput)))
            {
                readOutput(line);
            }
        }

        if (readError != null)
        {
            foreach (string line ; splitLines(Str.toString(strError)))
            {
                readError(line);
            }
        }

        if (externalWatch != null)
        {
            externalWatch(this);
        }

        return status;
    }
code: end

struct: Str
import: core.stdc.stdio
import: core.stdc.string
import: gobject.c.types
code: start
    /**
     * Converte sequências de grafemas s terminada em 0
     * estilo C em sequências de grafemas char[].
     */
    public static string toString(const(char)* s, size_t len = 0) pure
    {
        if (s is null)
        {
            return cast(string)null;
        }

        if (len == 0)
        {
            len = strlen(s);
        }

        return s[0 .. len].idup;
    }

    /**
     * Converta o vetor de grafemas s[] em um vetor de grafema
     * terminado em 0 no estilo C.
     */
    public static char* toStringz(string s) pure
    {
        if (s is null)
        {
            return null;
        }

        char[] copy;

        if (s.length == 0)
        {
            copy = "\0".dup;
        } else
        {
            /**
             * Precisa fazer uma cópia.
             */
            copy = new char[s.length + 1];
            copy[0..s.length] = s[];
            copy[s.length] = 0;
        }

        return copy.ptr;
    }

    /**
     *
     */
    public static char** toStringzArray(string[] args) pure
    {
        if (args is null)
        {
            return null;
        }

        char** argv = (new char*[args.length + 1]).ptr;
        int argc = 0;

        foreach (string p; args)
        {
            argv[argc++] = cast(char*)(p.dup~'\0');
        }

        argv[argc] = null;

        return argv;
    }

    /**
     *
     */
    public static char*** toStringzArray(string[][] args) pure
    {
        if (args is null)
        {
            return null;
        }

        char**[] argv = new char**[args.length + 1];
        int argc = 0;

        foreach (string[] p; args)
        {
            argv[argc++] = toStringzArray(p);
        }

        argv[argc] = null;

        return argv.ptr;
    }

    /**
     *
     */
    public static string[] toStringArray(const(char*)* args) pure
    {
        if (args is null)
        {
            return null;
        }

        string[] argv;

        while (*args !is null)
        {
            argv ~= toString(*args);
            args++;
        }

        return argv;
    }

    /**
     *
     */
    public static string[] toStringArray(const(char*)* args, size_t len) pure
    {
        string[] argv = new string[len];

        for ( int i; i < len; i++ )
        {
            argv[i] = toString(args[i]);
        }

        return argv;
    }

    /**
     *
     */
    public static string[][] toStringArray(char*** args) pure
    {
        string[][] argv;

        if (args is null)
        {
            return null;
        }

        while (*args !is null)
        {
            argv ~= toStringArray(*args);
            args++;
        }

        return argv;
    }

    /**
     *
     */
    public static void freeString(char* str)
    {
        g_free(str);
    }

    /**
     *
     */
    public static void freeStringArray(char** str)
    {
        g_strfreev(str);
    }

    /**
     *
     */
    public static void freeStringArray(char*** str)
    {
        while (*str !is null)
        {
            g_strfreev(*str);
            str++;
        }

        g_free(str);
    }
code: end

struct: String
class: StringG

struct: Thread
noCode: new

struct: Timeout
class: Timeout
cType:
import: core.time
import: std.conv
code: start
    /**
     * Mantém todas as delegações ociosas.
     */
    private bool delegate()[] timeoutListeners;

    /**
     * Nosso ID de tempo limite.
     */
    private uint timeoutID;

    /**
     * Cria um novo ciclo de tempo limite com a prioridade
     * comum, GPriority.DEFAULT.
     *
     * Observe que as funções de tempo limite podem ser
     * atrasadas devido ao procedimento de outras fontes
     * de eventos. Portanto, eles não devem ser considerados
     * para um tempo preciso. Após cada chamada da função
     * timeout, o tempo do próximo timeout é recalculado com
     * base no horário atual e no intervalo fornecido (não
     * tenta 'recuperar' os segundos perdidos em
     * procedimentos).
     *
     * Parâmetros:
     *     interval = O tempo limite em milissegundos.
     *     delegate() = A delegação a ser um procedimento.
     *     fireNow = Quando verdadeiro, a delegação será um
     *               procedimento imediatamente.
     */
    this(uint interval, bool delegate() dlg, bool fireNow=false)
    {
        if (fireNow && !dlg())
        {
            return;
        }

        timeoutListeners ~= dlg;
        timeoutID = g_timeout_add_full(GPriority.DEFAULT, interval, cast(GSourceFunc)&timeoutCallback, cast(void*)this, cast(GDestroyNotify)&destroyTimeoutNotify);
    }

    /**
     *
     */
    this(Duration interval, bool delegate() dlg, bool fireNow=false)
    {
        this(interval.total!"msecs".to!uint, dlg, fireNow);
    }

    /**
     * Cria um novo ciclo de tempo limite.
     *
     * Parâmetros:
     *     interval = O tempo limite em milissegundos.
     *     delegate() = A delegação a ser um procedimento.
     *     priority = Prioridade para a função de tempo limite.
     *     fireNow = Quando verdadeiro, a delegação será um
     *               procedimento imediato.
     */
    this(uint interval, bool delegate() dlg, GPriority priority, bool fireNow=false)
    {
        if (fireNow && !dlg())
        {
            return;
        }

        timeoutListeners ~= dlg;
        timeoutID = g_timeout_add_full(priority, interval, cast(GSourceFunc)&timeoutCallback, cast(void*)this, cast(GDestroyNotify)&destroyTimeoutNotify);
    }

    /**
     *
     */
    this(Duration interval, bool delegate() dlg, GPriority priority, bool fireNow=false)
    {
        this(interval.total!"msecs".to!uint, dlg, priority, fireNow);
    }

    /**
     * Cria um novo ciclo de tempo limite com a prioridade
     * comum, GPriority.DEFAULT.
     *
     * Parâmetros:
     *     delegate() = A delegação a ser um procedimento.
     *     seconds = Intervalo em segundos.
     *     fireNow = Quando verdadeiro, a delegação será
     *               um procedimento imediato.
     */
    this(bool delegate() dlg, uint seconds, bool fireNow=false)
    {
        if (fireNow && !dlg())
        {
            return;
        }

        timeoutListeners ~= dlg;
        timeoutID = g_timeout_add_seconds_full(GPriority.DEFAULT, seconds, cast(GSourceFunc)&timeoutCallback, cast(void*)this, cast(GDestroyNotify)&destroyTimeoutNotify);
    }

    /**
     *
     */
    this(bool delegate() dlg, Duration seconds, bool fireNow=false)
    {
        this(dlg, seconds.total!"seconds".to!uint, fireNow);
    }

    /**
     * Cria um novo ciclo de tempo limite.
     *
     * Parâmetros:
     *     delegate() = A delegação a ser um procedimento.
     *     seconds = Intervalo em segundos.
     *     priority = Prioridade para a função de tempo limite.
     *     fireNow = Quando verdadeiro, a delegação será um
     *               procedimento imediato.
     */
    this(bool delegate() dlg, uint seconds, GPriority priority, bool fireNow=false)
    {
        if (fireNow && !dlg())
        {
            return;
        }

        timeoutListeners ~= dlg;
        timeoutID = g_timeout_add_seconds_full(priority, seconds, cast(GSourceFunc)&timeoutCallback, cast(void*)this, cast(GDestroyNotify)&destroyTimeoutNotify);
    }

    /**
     *
     */
    this(bool delegate() dlg, Duration seconds, GPriority priority, bool fireNow=false)
    {
        this(dlg, seconds.total!"seconds".to!uint, priority, fireNow);
    }

    /**
     * Remove o tempo limite do GTK.
     */
    public void stop()
    {
        if (timeoutID > 0)
        {
            g_source_remove(timeoutID);
        }
    }

    /**
     * Remove o tempo limite do GTK.
     */
    ~this()
    {
        stop();
    }

    /**
     * Adiciona uma nova delegação a este ciclo de
     * tempo limite.
     *
     * Parâmetros:
     *     dlg =
     *     fireNow =
     */
    public void addListener(bool delegate() dlg, bool fireNow=false)
    {
        if (fireNow && !dlg())
        {
            return;
        }

        timeoutListeners ~= dlg;
    }

    /**
     * O procedimento de retorno de chamada de glib.
     *
     * Parâmetros:
     *     timeout =
     *
     * Devolve:
     */
    extern(C) static bool timeoutCallback(Timeout timeout)
    {
        bool runAgain = false;
        int i = 0;

        while (i<timeout.timeoutListeners.length)
        {
            if (!timeout.timeoutListeners[i]())
            {
                timeout.timeoutListeners = timeout.timeoutListeners[0..i] ~ timeout.timeoutListeners[i+1..$];
            } else
            {
                runAgain = true;
                ++i;
            }
        }

        return runAgain;
    }

    /**
     * Redefina o objeto de tempo limite quando ele for
     * removido no lado do GTK.
     */
    extern(C) static void destroyTimeoutNotify(Timeout timeout)
    {
        timeout.timeoutListeners.length = 0;
        timeout.timeoutID = 0;
    }
code: end

struct: TimeZone
noCode: new_local
noCode: new_utc
#TODO: Proper solution
version 2.68: noCode: new_identifier

struct: Tree
class: BBTree

version 2.66: start
    struct: Uri
    class: URI
version: end

struct: Util
move: build_filenamev Util
move: build_pathv Util
noCode: build_filenamev
noCode: build_pathv
code: start
    /**
     * Funcionamento igual a g_build_filename(), mas usa
     * os elementos do caminho como um vetor de sequências
     * de grafemas, em vez de varargs. Esta função destina-se
     * principalmente a vínculos de linguagem.
     *
     * Parâmetros:
     *     args = Sequências de grafemas contendo os elementos
     *            do caminho.
     *
     * Devolve: Uma sequência de grafemas recém-alocada que
     *          deve ser liberada com g_free().
     *
     * Desde: 2.8.
     */
    public static string buildFilename(string[] firstElement ... )
    {
        return Str.toString(g_build_filenamev(Str.toStringzArray(firstElement)));
    }

    /**
     * Comporta-se exatamente como g_build_path(), mas recebe
     * os elementos do caminho como um vetor de sequências de
     * grafemas, em vez de varargs. Esta função destina-se
     * principalmente a vínculos de linguagem.
     *
     * Parâmetros:
     *     separator = Uma sequência de grafemas usada para separar
     *                 os elementos do caminho.
     *     args = Uma sequência de grafemas contendo os elementos
     *            do caminho.
     *
     * Devolve: Uma sequência de grafemas recém-alocada que deve
     *          ser liberada com g_free().
     *
     * Desde: 2.8.
     */
    public static string buildPath(string separator, string[] firstElement ... )
    {
        return Str.toString(g_build_pathv(Str.toStringz(separator), Str.toStringzArray(firstElement)));
    }
code: end

struct: Variant
noCode: new_bytestring_array
noCode: new_object_path
noCode: new_signature
noCode: new_objv
noCode: new_bytestring
noCode: new_handle
noCode: new_take_string
code: start
    /**
     * Cria um caminho de objeto DBus GVariant com o conteúdo
     * de string. string deve ser um caminho de objeto DBus
     * válido. Use Variant.isObjectPath() se não tiver
     * certeza.
     *
     * Desde: 2.24.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     */
    public static Variant fromObjectPath(string path)
    {
        auto p = g_variant_new_object_path(Str.toStringz(path));

        if (p is null)
        {
            throw new ConstructionException("null returned by g_variant_new_object_path");
        }

        return new Variant(cast(GVariant*) p);
    }

    /**
     * Cria uma assinatura de tipo DBus GVariant com o conteúdo
     * de string. string deve ser uma assinatura de tipo DBus
     * válida. Use Variant.isSignature() se não tiver certeza.
     *
     * Desde: 2.24.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     */
    public static Variant fromSignature(string signature)
    {
        auto p = g_variant_new_signature(Str.toStringz(signature));

        if (p is null)
        {
            throw new ConstructionException("null returned by g_variant_new_signature");
        }

        return new Variant(cast(GVariant*) p);
    }

    /**
     * Cria um vetor de bytes GVariant com o conteúdo
     * de string. Esta função é como new Variant(string),
     * exceto que a string não precisa ser utf8 válida.
     *
     * O grafema terminador nulo no final da string é
     * armazenado no vetor.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     */
    public static Variant fromByteString(string byteString)
    {
        auto p = g_variant_new_bytestring(Str.toStringz(byteString));

        if (p is null)
        {
            throw new ConstructionException("null returned by g_variant_new_bytestring");
        }

        return new Variant(cast(GVariant*) p);
    }

    /**
     * Criar um vetor de caminhos de objeto Variant a partir
     * da matriz de strings fornecida. Cada string deve ser
     * um caminho de objeto Variant válido.
     *
     * Desde: 2.30.
     *
     * Parâmetros:
     *     strv = uma matriz de strings.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     */
    public static Variant fromObjv(string[] strv)
    {
        /**
         * GVariant * g_variant_new_objv (const gchar * const *strv,  gssize length);
         */
        auto p = g_variant_new_objv(Str.toStringzArray(strv), strv.length);

        if(p is null)
        {
            throw new ConstructionException("null returned by g_variant_new_objv(strv, length)");
        }

        return new Variant(cast(GVariant*) p);
    }

    /**
     * Cria um vetor de bytestring GVariant a partir do
     * vetor de strings fornecido. Se length for -1,
     * então strv terá terminação nula.
     *
     * Desde: 2.26.
     *
     * Parâmetros:
     *     strv = um vetor de strings.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     */
    public static Variant fromByteStringArray(string[] strv)
    {
        auto p = g_variant_new_bytestring_array(Str.toStringzArray(strv), strv.length);

        if(p is null)
        {
            throw new ConstructionException("null returned by g_variant_new_bytestring_array(strv, length)");
        }

        return new Variant(cast(GVariant*) p);
    }
code: end

struct: VariantType
noCode: new_maybe
code: start
    /**
     * Cria o tipo correspondente a uma instância talvez
     * contendo o tipo de tipo ou Nothing. É apropriado
     * chamar free() no valor de retorno.
     *
     * Parâmetros:
     *     element = a VariantType
     *
     * Devolve: um novo talvez VariantType.
     * Desde: 2.24.
     *
     * Lances: ConstructionException GTK+ não consegue criar o objeto.
     */
    public static VariantType newMaybe(VariantType element)
    {
        auto p = g_variant_type_new_maybe((element is null) ? null : element.getVariantTypeStruct());

        if(p is null)
        {
            throw new ConstructionException("null returned by new_maybe");
        }

        return new VariantType(cast(GVariantType*) p);
    }
code: end

struct:

move: atomic_int_add Atomic int_add
move: atomic_int_and Atomic int_and
move: atomic_int_compare_and_exchange Atomic int_compare_and_exchange
move: atomic_int_dec_and_test Atomic int_dec_and_test
move: atomic_int_exchange_and_add Atomic int_exchange_and_add
move: atomic_int_get Atomic int_get
move: atomic_int_inc Atomic int_inc
move: atomic_int_or Atomic int_or
move: atomic_int_set Atomic int_set
move: atomic_int_xor Atomic int_xor
move: atomic_pointer_add Atomic pointer_add
move: atomic_pointer_and Atomic pointer_and
move: atomic_pointer_compare_and_exchange Atomic pointer_compare_and_exchange
move: atomic_pointer_get Atomic pointer_get
move: atomic_pointer_or Atomic pointer_or
move: atomic_pointer_set Atomic pointer_set
move: atomic_pointer_xor Atomic pointer_xor

move: base64_decode Base64 decode
move: base64_encode Base64 encode
move: base64_encode_close Base64 encode_close
move: base64_encode_step Base64 encode_step

move: convert CharacterSet
move: convert_error_quark CharacterSet
move: convert_with_fallback CharacterSet
move: convert_with_iconv CharacterSet
move: filename_display_basename CharacterSet
move: filename_display_name CharacterSet
move: filename_from_utf8 CharacterSet
move: filename_to_utf8 CharacterSet
move: get_charset CharacterSet
move: get_codeset CharacterSet
move: get_filename_charsets CharacterSet
move: locale_from_utf8 CharacterSet
move: locale_to_utf8 CharacterSet

version 2.58: move: get_language_names_with_category CharacterSet
version 2.62: move: get_console_charset CharacterSet

move: child_watch_add Child
move: child_watch_add_full Child
move: child_watch_source_new Child

move: compute_checksum_for_bytes Checksum
move: compute_checksum_for_data Checksum
move: compute_checksum_for_string Checksum

move: datalist_clear DataList clear
move: datalist_foreach DataList foreach
move: datalist_get_data DataList get_data
move: datalist_get_flags DataList get_flags
move: datalist_id_dup_data DataList id_dup_data
move: datalist_id_get_data DataList id_get_data
move: datalist_id_remove_no_notify DataList id_remove_no_notify
move: datalist_id_replace_data DataList id_replace_data
move: datalist_id_set_data_full DataList id_set_data_full
move: datalist_init DataList init
move: datalist_set_flags DataList set_flags
move: datalist_unset_flags DataList unset_flags

move: dataset_destroy DataSet destroy
move: dataset_foreach DataSet foreach
move: dataset_id_get_data DataSet id_get_data
move: dataset_id_remove_no_notify DataSet id_remove_no_notify
move: dataset_id_set_data_full DataSet id_set_data_full

#move: clear_error Error
move: prefix_error Error
move: propagate_prefixed_error Error
move: set_error Error

move: access FileUtils
move: chdir FileUtils
move: close FileUtils
move: file_error_from_errno FileUtils
move: file_error_quark FileUtils
move: file_get_contents FileUtils
move: file_open_tmp FileUtils
move: file_read_link FileUtils
move: file_set_contents FileUtils
move: file_test FileUtils
move: mkdir_with_parents FileUtils
move: mkdtemp FileUtils
move: mkdtemp_full FileUtils
move: mkstemp FileUtils
move: mkstemp_full FileUtils
move: rmdir FileUtils
move: unlink FileUtils

move: direct_equal HashTable
move: direct_hash HashTable
move: double_equal HashTable
move: double_hash HashTable
move: int64_equal HashTable
move: int64_hash HashTable
move: int_equal HashTable
move: int_hash HashTable
move: str_equal HashTable
move: str_hash HashTable

move: hostname_is_ascii_encoded Hostname is_ascii_encoded
move: hostname_is_ip_address Hostname is_ip_address
move: hostname_is_non_ascii Hostname is_non_ascii
move: hostname_to_ascii Hostname to_ascii
move: hostname_to_unicode Hostname to_unicode

move: idle_add Idle add
move: idle_add_full Idle add_full
move: idle_remove_by_data Idle remove_by_data
move: idle_source_new Idle source_new

move: dcgettext Internationalization
move: dgettext Internationalization
move: dngettext Internationalization
move: dpgettext Internationalization
move: dpgettext2 Internationalization
move: get_language_names Internationalization
move: get_locale_variants Internationalization
move: strip_context Internationalization

move: io_add_watch IOChannel
move: io_add_watch_full IOChannel
move: io_create_watch IOChannel

move: main_current_source MainLoop
move: main_depth MainLoop
move: poll MainLoop

move: markup_collect_attributes MarkupParseContext
move: markup_error_quark MarkupParseContext
move: markup_escape_text MarkupParseContext
move: markup_printf_escaped MarkupParseContext
move: markup_vprintf_escaped MarkupParseContext

move: clear_pointer Memory
move: free Memory
move: malloc Memory
move: malloc0 Memory
move: malloc0_n Memory
move: malloc_n Memory
move: mem_is_system_malloc Memory
move: mem_profile Memory
move: mem_set_vtable Memory
move: memdup Memory
move: realloc Memory
move: realloc_n Memory
move: try_malloc Memory
move: try_malloc0 Memory
move: try_malloc0_n Memory
move: try_malloc_n Memory
move: try_realloc Memory
move: try_realloc_n Memory

move: slice_alloc MemorySlice
move: slice_alloc0 MemorySlice
move: slice_copy MemorySlice
move: slice_free1 MemorySlice
move: slice_free_chain_with_offset MemorySlice
move: slice_get_config MemorySlice
move: slice_get_config_state MemorySlice
move: slice_set_config MemorySlice

move: log MessageLog
move: log_default_handler MessageLog
move: log_remove_handler MessageLog
move: log_set_always_fatal MessageLog
move: log_set_default_handler MessageLog
move: log_set_fatal_mask MessageLog
move: log_set_handler MessageLog
move: log_set_handler_full MessageLog
move: logv MessageLog

move: on_error_query Messages
move: on_error_stack_trace Messages
move: print Messages
move: printerr Messages
move: set_print_handler Messages
move: set_printerr_handler Messages

move: option_error_quark OptionContext

move: pattern_match PatternSpec
move: pattern_match_simple PatternSpec
move: pattern_match_string PatternSpec

move: intern_static_string Quark
move: intern_string Quark
move: quark_from_static_string Quark
move: quark_from_string Quark
move: quark_to_string Quark
move: quark_try_string Quark

move: random_double Rand
move: random_double_range Rand
move: random_int Rand
move: random_int_range Rand
move: random_set_seed Rand

move: shell_error_quark ShellUtils
move: shell_parse_argv ShellUtils
move: shell_quote ShellUtils
move: shell_unquote ShellUtils

move: spawn_async Spawn async
move: spawn_async_with_pipes Spawn async_with_pipes
move: spawn_check_exit_status Spawn check_exit_status
move: spawn_close_pid Spawn close_pid
move: spawn_command_line_async Spawn command_line_async
move: spawn_command_line_sync Spawn command_line_sync
move: spawn_error_quark Spawn error_quark
move: spawn_exit_error_quark Spawn exit_error_quark
move: spawn_sync Spawn sync

version 2.58: start
    move: spawn_async_with_fds Spawn async_with_fds
version: end

struct: Spawn
noCode: async_with_pipes

move: ascii_digit_value Str
move: ascii_dtostr Str
move: ascii_formatd Str
move: ascii_strcasecmp Str
move: ascii_strdown Str
move: ascii_strncasecmp Str
move: ascii_strtod Str
move: ascii_strtoll Str
move: ascii_strtoull Str
move: ascii_strup Str
move: ascii_tolower Str
move: ascii_toupper Str
move: ascii_xdigit_value Str
move: printf Str
move: printf_string_upper_bound Str
move: snprintf Str
move: sprintf Str
move: stpcpy Str
move: str_has_prefix Str has_prefix
move: str_has_suffix Str has_suffix
move: str_is_ascii Str is_ascii
move: str_match_string Str match_string
move: str_to_ascii Str to_ascii
move: str_tokenize_and_fold Str tokenize_and_fold
move: strcanon Str
move: strcasecmp Str
move: strchomp Str
move: strchug Str
move: strcmp0 Str
move: strcompress Str
move: strconcat Str
move: strdelimit Str
move: strdown Str
move: strdup Str
move: strdup_printf Str
move: strdup_vprintf Str
move: strdupv Str
move: strerror Str
move: strescape Str
move: strfreev Str
move: strjoin Str
move: strjoinv Str
move: strlcat Str
move: strlcpy Str
move: strncasecmp Str
move: strndup Str
move: strnfill Str
move: strreverse Str
move: strrstr Str
move: strrstr_len Str
move: strsignal Str
move: strsplit Str
move: strsplit_set Str
move: strstr_len Str
move: strtod Str
move: strup Str
move: strv_get_type Str
move: strv_length Str
move: strv_contains Str
move: vasprintf Str
move: vprintf Str
move: vsnprintf Str
move: vsprintf Str

version !OSX: start
    move: fprintf Str
    move: vfprintf Str
version: end

version 2.54: start
    move: ascii_string_to_signed Str
    move: ascii_string_to_unsigned Str
version: end

version 2.60: move: strv_equal Str

version <2.70: start
    move: string_new String
    move: string_new_len String
    move: string_sized_new String
version: end

move: bit_lock Thread
move: bit_trylock Thread
move: bit_unlock Thread
move: get_num_processors Thread
move: pointer_bit_lock Thread
move: pointer_bit_trylock Thread
move: pointer_bit_unlock Thread

move: timeout_add Timeout add
move: timeout_add_full Timeout add_full
move: timeout_add_seconds Timeout add_seconds
move: timeout_add_seconds_full Timeout add_seconds_full
move: timeout_source_new Timeout source_new
move: timeout_source_new_seconds Timeout source_new_seconds

move: get_current_time TimeVal
move: get_monotonic_time TimeVal
move: get_real_time TimeVal
move: usleep TimeVal

move: ucs4_to_utf16 Unicode
move: ucs4_to_utf8 Unicode
move: unichar_break_type Unicode
move: unichar_combining_class Unicode
move: unichar_compose Unicode
move: unichar_decompose Unicode
move: unichar_digit_value Unicode
move: unichar_fully_decompose Unicode
move: unichar_get_mirror_char Unicode
move: unichar_get_script Unicode
move: unichar_isalnum Unicode
move: unichar_isalpha Unicode
move: unichar_iscntrl Unicode
move: unichar_isdefined Unicode
move: unichar_isdigit Unicode
move: unichar_isgraph Unicode
move: unichar_islower Unicode
move: unichar_ismark Unicode
move: unichar_isprint Unicode
move: unichar_ispunct Unicode
move: unichar_isspace Unicode
move: unichar_istitle Unicode
move: unichar_isupper Unicode
move: unichar_iswide Unicode
move: unichar_iswide_cjk Unicode
move: unichar_isxdigit Unicode
move: unichar_iszerowidth Unicode
move: unichar_to_utf8 Unicode
move: unichar_tolower Unicode
move: unichar_totitle Unicode
move: unichar_toupper Unicode
move: unichar_type Unicode
move: unichar_validate Unicode
move: unichar_xdigit_value Unicode
move: unicode_canonical_decomposition Unicode
move: unicode_canonical_ordering Unicode
move: unicode_script_from_iso15924 Unicode
move: unicode_script_to_iso15924 Unicode
move: utf16_to_ucs4 Unicode
move: utf16_to_utf8 Unicode
move: utf8_casefold Unicode
move: utf8_collate Unicode
move: utf8_collate_key Unicode
move: utf8_collate_key_for_filename Unicode
move: utf8_find_next_char Unicode
move: utf8_find_prev_char Unicode
move: utf8_get_char Unicode
move: utf8_get_char_validated Unicode
move: utf8_normalize Unicode
move: utf8_offset_to_pointer Unicode
move: utf8_pointer_to_offset Unicode
move: utf8_prev_char Unicode
move: utf8_strchr Unicode
move: utf8_strdown Unicode
move: utf8_strlen Unicode
move: utf8_strncpy Unicode
move: utf8_strrchr Unicode
move: utf8_strreverse Unicode
move: utf8_strup Unicode
move: utf8_substring Unicode
move: utf8_to_ucs4 Unicode
move: utf8_to_ucs4_fast Unicode
move: utf8_to_utf16 Unicode
move: utf8_validate Unicode
version 2.52: move: utf8_make_valid Unicode
version 2.60: move: utf8_validate_len Unicode

version !Windows: start
    move: unix_error_quark UnixUtils error_quark
    move: unix_fd_add UnixUtils fd_add
    move: unix_fd_add_full UnixUtils fd_add_full
    move: unix_fd_source_new UnixUtils fd_source_new
    move: unix_open_pipe UnixUtils open_pipe
    move: unix_set_fd_nonblocking UnixUtils set_fd_nonblocking
    move: unix_signal_add UnixUtils signal_add
    move: unix_signal_add_full UnixUtils signal_add_full
    move: unix_signal_source_new UnixUtils signal_source_new
version: end

move: filename_from_uri URI
move: filename_to_uri URI
version <2.66: start
    move: uri_escape_string URI
    move: uri_list_extract_uris URI
    move: uri_parse_scheme URI
    move: uri_unescape_segment URI
    move: uri_unescape_string URI
version: end

version 2.52: start
    move: uuid_string_is_valid Uuid string_is_valid
    move: uuid_string_random Uuid string_random
version: end

move: atexit Util
move: basename Util
move: bit_nth_lsf Util
move: bit_nth_msf Util
move: bit_storage Util
move: build_path Util
move: environ_getenv Util
move: environ_setenv Util
move: environ_unsetenv Util
move: find_program_in_path Util
move: format_size Util
move: format_size_for_display Util
move: format_size_full Util
move: get_application_name Util
move: get_environ Util
move: get_current_dir Util
move: get_home_dir Util
move: get_host_name Util
move: get_prgname Util
move: get_real_name Util
move: get_system_config_dirs Util
move: get_system_data_dirs Util
move: get_tmp_dir Util
move: get_user_cache_dir Util
move: get_user_config_dir Util
move: get_user_data_dir Util
move: get_user_name Util
move: get_user_runtime_dir Util
move: get_user_special_dir Util
move: getenv Util
move: listenv Util
move: nullify_pointer Util
move: parse_debug_string Util
move: path_get_basename Util
move: path_get_dirname Util
move: path_is_absolute Util
move: path_skip_root Util
move: qsort_with_data Util
move: reload_user_special_dirs_cache Util
move: set_application_name Util
move: set_prgname Util
move: setenv Util
move: spaced_primes_closest Util
move: unsetenv Util

version 2.58: move: canonicalize_filename Util
version 2.64: move: get_os_info Util

move: check_version Version
